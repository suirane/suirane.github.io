>参考文档：
>
>[X264算法参数一（X264线程参数）](https://blog.csdn.net/CrystalShaw/article/details/89572684?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161819618916780274194581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161819618916780274194581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-89572684.nonecase&utm_term=x264)
>
>[X264算法参数二（VUI参数配置）](https://blog.csdn.net/CrystalShaw/article/details/105246214?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161819618916780274194581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161819618916780274194581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-105246214.nonecase&utm_term=x264)
>
>[X264算法参数四（analyse parameters）](https://blog.csdn.net/CrystalShaw/article/details/90405879?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161819618916780274194581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161819618916780274194581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-8-90405879.nonecase&utm_term=x264)
>
>[X264算法参数五（码控参数）](https://blog.csdn.net/CrystalShaw/article/details/89556126?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161797224316780357262993%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161797224316780357262993&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-4-89556126.nonecase&utm_term=x264)

## ABR，CQP，CRF

`X264` 显式支持的一趟码率控制方法有：`ABR`,、`CQP`、 `CRF` ，缺省（即默认）方法是`CRF`。这三种方式的优先级是 **`ABR` > `CQP` > `CRF`**

`bitrate` 和 `QP` 都没有缺省值，一旦设置他们就表示要按照相应的码率控制方法进行编码，`CRF`有缺省值23，没有任何关于编码控制的设置时，就按照缺省值 23 来编码。



**一般的使用建议：**

**CQP** – 不推荐使用，在一些算法验证工作中会使用这种模式。适合存线下文件——对应一种主观清晰度的设定。

**CRF** – 适合在 **一遍** 编码质量而输出文件大小 或 码率不是太紧要的场景下使用，一般网络压片使用CRF。

**1 pass ABR** – 适用于流媒体、目标码率受限的实时应用。

**2 pass VBR** – 适用于有码率限制、有时间二次编码的非实时应用。



### CQP

**CQP（ConstantQuantization Parameter）恒定量化参数，无缺省值** (不建议使用)

最简单的码率控制方式，每帧图像都按照一个特定的`QP`来编码，每帧编码后的数据量有多大是未知的。

参数`qp_constant`设置的是 P 帧的 QP。I，B 帧的 QP 根据`f_ip_factor`，`f_pb_factor`计算得到。

连续多个 `B帧` 时， `QP` 会渐增。 `QP` 值越小，编码视觉质量越好。 `QP=0` 为无失真编码。

> x264 YUV420格式 8 比特采样的 QP 范围是[0, 51]。
>
> 在研究编码算法的时候，一般会选用 CQP 方法，设定 QP 为**24，28，32，36，40**等（一般选4个QP值），编码得到RD曲线，然后比较算法优劣。 

**相同视觉质量时，`CQP`编码输出的文件会比`CRF`模式更大。一般而言`CRF`都能代替`CQP`方法，不过`CQP`因为完全不需要预测所以它会运行得更快一些。**

帧的重要级别为：IDR帧 > I帧 > P帧 > 做参考的B帧 > 不做参考的B帧。QP可以依次增大。

* QPmin：默认值 0。定义 X264 可以使用的最小量化值。量化值越小，输出视频质量就越好。
  * 当QP小于某一个值后，编码输出的宏块质量与原始块极为相近，这时没必要继续降低QP。
  * 如果开启了自适应量化器（默认开启），不建议提高 QPmin 的值，因为这会降低平滑背景区域的视觉质量。
* QPmax：默认值 51。定义 X264 可以使用的最大量化值。默认值51是 H.264 规格中可供使用的最大量化值。
  * 如果想要控制X264输出的最低品质，可以将此值设置的小一些。
  * QPmin 和 QPmax 在 CRF，ABR 方法下是有效的，过低的设置 QPmax，可能造成 ABR 码率控制失败。不建议调整这个参数。
* QPstep：默认值 4。设置两帧间量化值的最大变化幅度。

帧间QP变化，帧内宏块QP不变，输出码率未知，各帧输出视觉质量有变化（高QP低码率的情况下会更明显）。



### CRF

**CRF（Constant Rate Factor），恒定Rate Factor（码率系数），缺省值23**

`CQP`是把某个量化值作为目标，`bitrate`是把某个输出文件大小作为目标，**而`CRF`则是把某个输出“视觉质量”作为目标。**

`CRF`可以提供跟`QP` **一样的视觉质量**，**但是文件更小**，`CRF`是通过降低那些`less important`帧的质量来达到此目的的。

`less important`的意思是那些过于耗费码率、难肉眼察觉的帧，比如复杂或者高速运行的场景。省下来的码率会分配给其它更有效的帧。

> 在 X264 编码器内部 CRF 和 bitrate 采用了相同的调整策略，只是它不遵循一个特定的输出码率。

它也是通过改变不同重要级别帧（I,P,B类型），以及帧内不同宏块类型（**高速运动，复杂纹理，平坦区域**）的`QP`值，以此来调整输出视觉质量。

和`QP`的范围一样`RF`的范围也是[0,51]。其中 0 为无损模式，23为缺省，51质量最差。和`QP`一样的趋势。**`RF`值加6，输出码率大概减少一半；减6，输出码率翻倍。**

**从主观上讲，18-28是一个合理的范围，18往往被认为从视觉上看是近似无损的。**

帧间`QP`变化，帧内宏块`QP`变化，输出码率未知，各帧输出视觉质量基本恒定。



### ABR

**ABR（Average Bit Rate）, 恒定平均目标码率。** 想要选择这种码率控制方法，必须先设置`bitrate`。

`X264`中`bitrate`的单位是`Kbps`. `--bitrate 128`指的是设置目标码率为`128Kbps`, 这样一秒钟的数据量为 128K bit/8 = 16K Byte。

如果输入为`352x288@15fps`，相当于128Kbit/(352*288*15) = 0.086比特每像素。编码后每个像素平均分配不到0.1个比特。

与`ABR`相应的技术有`CBR`,`VBR`。这些码率控制技术首先都是在音频编码中采用，是解决音频编码采用什么样的比特率最优的问题。

**`CBR`编码码比特率基本保持恒定在目标比特率，有利于流式播放。**

`CBR`的缺点在于**复杂场景码率不够用**，简单场景码率浪费，因此编码内容的视觉质量不稳定。通常在较低比特率下，这种质量的变化会更加明显。

`VBR`编码为简单场景分配较大的`QP`，为复杂的场景分配较小的`QP`，得到基本稳定的输出视觉质量。

相对于`CBR`，在相同文件大小的条件下，`VBR`的输出结果要比`CBR`好的多，这有利于媒体下载和本地存储。

**VBR的缺点在于输出码流大小不可控**。同时对于复杂度恒定的内容（例如新闻播音）没什么优势。

`ABR`编码为简单场景分配较少的比特，从而留出足量的比特用于生成高质量的复杂部分。使得有限的比特数能够在不同的场景间合理分配，这类似于`VBR`。

同时`ABR`分配码率，使得在一定时间内，平均码率趋近于目标码率，这样可以控制输出文件大小，这点类似于`CBR`。

**因此可以认为`ABR`是`CBR`和`VBR`的一种折中优化方案。**



**比较这三种码率控制方式如下：**

| \    | 视觉质量稳定性 | 即时输出码率 | 输出文件大小                                           |
| ---- | -------------- | ------------ | ------------------------------------------------------ |
| CBR  | 不稳定         | 恒定         | 可控                                                   |
| VBR  | 稳定           | 变化         | 不可控                                                 |
| ABR  | 基本稳定       | 变化         | 可控（即时码率变化，但一段时期内平均码率趋近目标码率） |



**在X264（version 142）版本中，选用ABR需要注意两个设置：**

* **fps**。ABR会根据帧率来估算每帧的平均数据量，bitrate/fps 为平均一帧数据量。
  * 当输入视频源为 YUV 数据，需要显式的指定正确的帧率--fps，否则 X264 会用缺省的 25fps 来计算，有可能控制不到设定的目标码率。
* **输出帧 pts 计算**。ABR算法中用到不同帧的 pts 作为帧间距离，如果没有设置输出帧的pts值，X264会报“non-strictly-monotonic PTS”警告。
  * 编码出来的视频文件码率很小，根本达不到bitrate的设置，同时视频质量很差，几乎都为马赛克。两种方法解决这个问题：
    * 设置`param.b_vfr_input = 0`，这时用 fps 而不是 timebase，timestamps 来计算帧间距离
    * 在解码后主动更新 pts, pic_out.i_pts++。这两种方式都可以避免ABR码率控制失效的问题。



**分析视频编码码率控制可以通过三个因素：**

1. 视觉质量稳定性，利于视觉主观质量；
2. 即时输出码率，相当于每帧编码输出比特数；
3. 输出视频文件大小可控，利于传输，存储。



## 码控参数

| 参数名称          | 参数类型    | 参数含义                                                     | 备注说明                                                     | 模式             |
| ----------------- | ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- |
| i_rc_method       | int         | 码控方法                                                     | X264_RC_CQP（0）：固定的量化参数，随着视频运动情况,码率会上升和下降。但是码率不可控，码率大小取决于残差大小。<br>X264_RC_CRF（1）：恒定质量编码(运动/纹理复杂场景，码率上升；静态/纹理简单的画面，码率下降)<br>X264_RC_ABR（2）：编码出来的视频码率在一个恒定值左右波动。该模式下目标码率和峰值码率配置相等的时候，就是CBR。 |                  |
| i_qp_constant     | int         | 固定量化因子                                                 | X264_RC_CQP模式下有效，0：表示无损压缩。23：默认值           | X264_RC_CQP模式  |
| i_qp_min          | int         | 允许的最小量化值                                             | 控制P帧编码质量，一般这个值不能配置太小，P帧编码质量过高，会出现视频闪烁现象。可以尝试配置为i_qp_max/2后进行微调。 |                  |
| i_qp_max          | int         | 允许的最大量化值                                             | 控制I帧编码质量。                                            |                  |
| i_qp_step         | int         | 帧间最大量化步长                                             | 相邻两帧之间QP量化值之差的最大值。                           |                  |
| i_bitrate         | int         | 目标码率，单位kbps                                           | 一般情况下：<br>480P    1800Kbps<br>720P    3500Kbps<br>1080P    8500Kbps<br>目前经过压缩后不需要这么大的对应码率 |                  |
| f_rf_constant     | float       | 实际图像质量                                                 | X264_RC_CRF模式下有效，配置CRF模式下期望得到的视频质量。<br>值越大图像越花，越小越清晰 | X264_RC_CRF模式  |
| f_rf_constant_max | float       | 实际图像质量的最大值                                         | X264_RC_CRF模式下有效，配置CRF模式下最差码率质量的门限。<br>允许的最差画质对应RF阈值，VBV使用 | X264_RC_CRF模式  |
| f_rate_tolerance  | float       | 瞬时码率可以偏离的倍数                                       | 范围0.1~100.0，默认为1.0。                                   | X264_RC_ABR模式  |
| i_vbv_max_bitrate | int         | 瞬时峰值码率，单位kbps                                       | 该值与i_bitrate相等，就是CBR恒定码控模式。                   | X264_RC_ABR模式  |
| i_vbv_buffer_size | int         | 码率控制缓冲区的大小，单位kbit                               | 电影电视剧，场景建议配置3倍i_vbv_max_bitrate。               |                  |
| f_vbv_buffer_init | float       | 初始VBV数据大小                                              | 码率控制缓冲区数据满足一定百分比之后才能开始回放。参数小于等于1时是百分比，大于1时是kbit。默认0.9 |                  |
| f_ip_factor       | float       | 设置平均 I 帧 QP 相比 P 帧 QP 的差值                         | 更高的值意味着更高的 I 帧质量。ipratio 与 I 帧 QP 成反比例关系。等于1的时候，I帧QP与P帧相同。 |                  |
| f_pb_factor       | float       | 设置平均 P 帧 QP 相比 P 帧 QP 的差值                         | 更高的值意味着更高的 P 帧质量。pbratio 与 P 帧 QP 成反比例关系。等于1的时候，P帧QP与B帧相同。 |                  |
| b_filler          | int         | 码强行补足率                                                 | CBR模式下，码率不够，强行添加填充位，凑码率。                | CBR模式          |
| i_aq_mode         | int         | 自适应量化参数。                                             | X264_AQ_NONE（0）：不开启AQ模式，帧内宏块全部使用同一QP或者固定的QP表。该模式下，视频PSNR值相对于其他码控模式偏高。<br>X264_AQ_VARIANCE（1）：使用方差动态计算每个宏块的QP。<br>X264_AQ_AUTOVARIANCE（2）：方差自适应模式，会先遍历一次全部宏块，统计出一些中间参数，之后利用这些参数，对每个宏块计算QP。<br>X264_AQ_AUTOVARIANCE_BIASED（3）：偏移方差自适应模式，在该模式下BiasStrength即为原始的Strength值。最终每个宏块的  QP。 |                  |
| f_aq_strength     | float       | 自适应量化强度。减少平坦区域块效应和纹理区域模糊效应的强度。 | 强度越高，高频信息消减越多，应对平坦区域的块效益就越好，但是对于纹理区域的模糊就越大。一般来说画面动态较高就选低点的aq-strength（0.6-0.8），以免在平坦区域浪费太多码率，而损伤了动态区域；在静态画面较多的场景就选高点aq-strength（>=1.0），防止暗部因比特不够而产生色带。 |                  |
| b_mb_tree         | int         | 是否开启基于macroblock（宏块）的qp控制方法，开启之后质量有所提升 | macroblock  tree工作原理：决定MB使用何种大小的qp值进行量化。对每个MB处理，向前预测一定数量的帧，记录该MB被参考的情况，qp的大小与被参考次数成反比。 |                  |
| i_lookahead       | int         | rc-lookahead决定mb_tree向前预测的帧数                        | 配置该参数后，编码器并不是每来一帧就编码一帧，而是先缓存i_lookahead个帧，将i_lookahead个帧缓存满后再开始出编码。该参数的设置会影响压缩的效果，同时调大该参数也能够使得VBV获得更精确的码率控制，但同时也会增加编码的时间，提高实时编码的时延。 |                  |
| b_stat_write      | int         | 统计写入开关                                                 | 1pass时，是否将统计数据写入到文件psz_stat_out中              |                  |
| *psz_stat_out     | char        | 1pass统计数据写入文件名                                      | UTF-8                                                        |                  |
| b_stat_read       | int         | 2pass时，是否从文件psz_stat_in中读入统计数据                 |                                                              |                  |
| *psz_stat_in      | char        | 2pass读取统计数据文件名                                      | UTF-8                                                        |                  |
| f_qcompress       | float       | 线性量化控制                                                 | 0.0：固定码率，CBR。1.0：固定量化值，CQP                     |                  |
| f_qblur           | float       | 短时模糊量化                                                 | 时间上模糊量化，减少QP的波动(after curve compression)。对统计文件结果平滑量化值比例的最大值<br>范围0~99.9，默认0.5。只用于2-pass | 2-pass           |
| f_complexity_blur | float       | 短时模糊复杂度                                               | 时间上模糊复杂性，减少QP的波动(before curve compression)。根据相邻帧平滑量化值比例的最大值<br>范围0~99.0，默认20.0，只用于2-pass和质量模式 | 2-pass和质量模式 |
| *zones            | x264_zone_t | 码率控制覆盖                                                 | 不同区域不用分配                                             |                  |
| i_zones           | int         | zone_t的数量                                                 |                                                              |                  |
| *psz_zones        | char        | 指定区的另一种码控方法                                       |                                                              |                  |